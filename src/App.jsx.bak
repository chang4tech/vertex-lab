import React, { useState, useEffect, useRef, useCallback } from 'react';
import MindMapCanvas from './MindMapCanvas.jsx';

function MenuBar({
  onExport, onImport, onNew, onUndo, onRedo, onDelete, onCenter, onZoomIn, onZoomOut, onResetZoom, onToggleDark,
  nodes, setNodes, setUndoStack, setRedoStack, setSelectedNodeId, canvasRef
}) {
  const fileInputRef = useRef();
  const [openMenu, setOpenMenu] = useState(null); // 'file' | 'edit' | 'view' | 'settings' | null

  // Close menu when clicking outside
  useEffect(() => {
    if (!openMenu) return;

    const handleClickOutside = (event) => {
      // Don't close if clicking inside a menu
      if (event.target.closest('.menu-dropdown')) return;
      // Don't close if clicking on a menu trigger
      if (event.target.closest('.menu-trigger')) return;
      setOpenMenu(null);
    };

    document.addEventListener('click', handleClickOutside);
    return () => document.removeEventListener('click', handleClickOutside);
  }, [openMenu]);

  const menuDropdown = (type, items) => openMenu === type && (
    <div className="menu-dropdown" style={{
      position: 'absolute',
      top: 32,
      left: 0,
      background: '#fff',
      border: '1px solid #eee',
      borderRadius: 4,
      boxShadow: '0 2px 8px rgba(0,0,0,0.12)',
      minWidth: 140,
      zIndex: 1000,
      padding: '4px 0'
    }}>{items}</div>
  );

  return (
    <nav style={{
      width: '100%', background: '#fff', borderBottom: '1px solid #eee',
      display: 'flex', alignItems: 'center', padding: '0 24px', height: 48, zIndex: 200, position: 'fixed', top: 0, left: 0, right: 0
    }}>
      <div style={{ fontWeight: 700, fontSize: 18, marginRight: 32 }}>🧠 MindMap</div>
      <div style={{ display: 'flex', gap: 24 }}>
        <div style={{ cursor: 'pointer', position: 'relative' }}>
          <span className="menu-trigger" onClick={(e) => {
            e.preventDefault();
            console.log('File menu clicked');
            setOpenMenu(openMenu === 'file' ? null : 'file');
          }}>File</span>
          {menuDropdown('file', <>
            <div
              style={{ padding: '8px 20px', cursor: 'pointer', display: 'flex', justifyContent: 'space-between' }}
              onClick={(e) => {
                e.preventDefault();
                e.stopPropagation();
                console.log('New clicked');
                onNew();
                setOpenMenu(null);
              }}
            >
              <span>New</span>
              <span style={{ opacity: 0.5, marginLeft: 20 }}>⌘N</span>
            </div>
            <div
              style={{ padding: '8px 20px', cursor: 'pointer', display: 'flex', justifyContent: 'space-between' }}
              onClick={(e) => {
                e.preventDefault();
                e.stopPropagation();
                console.log('Export JSON clicked');
                onExport();
                setOpenMenu(null);
              }}
            >
              <span>Export JSON</span>
              <span style={{ opacity: 0.5, marginLeft: 20 }}>⌘S</span>
            </div>
            <div
              style={{ padding: '8px 20px', cursor: 'pointer', display: 'flex', justifyContent: 'space-between' }}
              onClick={(e) => {
                e.preventDefault();
                e.stopPropagation();
                console.log('Export PNG clicked');
                onExportPNG();
                setOpenMenu(null);
              }}
            >
              <span>Export PNG</span>
              <span style={{ opacity: 0.5, marginLeft: 20 }}>⇧⌘S</span>
            </div>
            <div
              style={{ padding: '8px 20px', cursor: 'pointer', display: 'flex', justifyContent: 'space-between' }}
              onClick={(e) => {
                e.preventDefault();
                e.stopPropagation();
                console.log('Import JSON clicked');
                fileInputRef.current.click();
                setOpenMenu(null);
              }}
            >
              <span>Import JSON</span>
              <span style={{ opacity: 0.5, marginLeft: 20 }}>⌘O</span>
            </div>
            <input
              ref={fileInputRef}
              type="file"
              accept="application/json"
              style={{ display: 'none' }}
              onChange={e => {
                console.log('File input change event');
                const file = e.target.files[0];
                if (!file) {
                  console.log('No file selected');
                  return;
                }
                console.log('Reading file:', file.name);
                const reader = new FileReader();
                reader.onload = evt => {
                  try {
                    const content = evt.target.result;
                    console.log('File content:', content);
                    const data = JSON.parse(content);
                    console.log('Parsed data:', data);
                    if (!Array.isArray(data)) {
                      throw new Error('Imported data must be an array');
                    }
                    if (!data.every(n => n.id && typeof n.x === 'number' && typeof n.y === 'number' && typeof n.label === 'string')) {
                      throw new Error('Invalid node format');
                    }
                    console.log('Importing valid data:', data.length, 'nodes');
                    onImport(data);
                  } catch (error) {
                    console.error('Import error:', error);
                    alert(`Import failed: ${error.message}`);
                  }
                };
                reader.onerror = error => {
                  console.error('File read error:', error);
                  alert('Failed to read file');
                };
                reader.readAsText(file);
                e.target.value = '';
              }}
            />
          </>)}
        </div>
        <div style={{ cursor: 'pointer', position: 'relative' }}>
          <span className="menu-trigger" onClick={(e) => {
            e.preventDefault();
            console.log('Edit menu clicked');
            setOpenMenu(openMenu === 'edit' ? null : 'edit');
          }}>Edit</span>
          {menuDropdown('edit', <>
            <div
              style={{ padding: '8px 20px', cursor: 'pointer', display: 'flex', justifyContent: 'space-between' }}
              onClick={(e) => {
                e.preventDefault();
                e.stopPropagation();
                console.log('Undo clicked');
                onUndo();
                setOpenMenu(null);
              }}
            >
              <span>Undo</span>
              <span style={{ opacity: 0.5, marginLeft: 20 }}>⌘Z</span>
            </div>
            <div
              style={{ padding: '8px 20px', cursor: 'pointer', display: 'flex', justifyContent: 'space-between' }}
              onClick={(e) => {
                e.preventDefault();
                e.stopPropagation();
                console.log('Redo clicked');
                onRedo();
                setOpenMenu(null);
              }}
            >
              <span>Redo</span>
              <span style={{ opacity: 0.5, marginLeft: 20 }}>⇧⌘Z</span>
            </div>
            <div
              style={{ padding: '8px 20px', cursor: 'pointer', display: 'flex', justifyContent: 'space-between' }}
              onClick={(e) => {
                e.preventDefault();
                e.stopPropagation();
                console.log('Delete clicked');
                onDelete();
                setOpenMenu(null);
              }}
            >
              <span>Delete</span>
              <span style={{ opacity: 0.5, marginLeft: 20 }}>⌫</span>
            </div>
          </>)}
        </div>
        <div style={{ cursor: 'pointer', position: 'relative' }}>
          <span className="menu-trigger" onClick={(e) => {
            e.preventDefault();
            console.log('View menu clicked');
            setOpenMenu(openMenu === 'view' ? null : 'view');
          }}>View</span>
          {menuDropdown('view', <>
            <div
              style={{ padding: '8px 20px', cursor: 'pointer', display: 'flex', justifyContent: 'space-between' }}
              onClick={(e) => {
                e.preventDefault();
                e.stopPropagation();
                console.log('Center clicked');
                onCenter();
                setOpenMenu(null);
              }}
            >
              <span>Center</span>
              <span style={{ opacity: 0.5, marginLeft: 20 }}>⌘0</span>
            </div>
            <div
              style={{ padding: '8px 20px', cursor: 'pointer', display: 'flex', justifyContent: 'space-between' }}
              onClick={(e) => {
                e.preventDefault();
                e.stopPropagation();
                console.log('Zoom In clicked');
                onZoomIn();
                setOpenMenu(null);
              }}
            >
              <span>Zoom In</span>
              <span style={{ opacity: 0.5, marginLeft: 20 }}>⌘+</span>
            </div>
            <div
              style={{ padding: '8px 20px', cursor: 'pointer', display: 'flex', justifyContent: 'space-between' }}
              onClick={(e) => {
                e.preventDefault();
                e.stopPropagation();
                console.log('Zoom Out clicked');
                onZoomOut();
                setOpenMenu(null);
              }}
            >
              <span>Zoom Out</span>
              <span style={{ opacity: 0.5, marginLeft: 20 }}>⌘-</span>
            </div>
            <div
              style={{ padding: '8px 20px', cursor: 'pointer', display: 'flex', justifyContent: 'space-between' }}
              onClick={(e) => {
                e.preventDefault();
                e.stopPropagation();
                console.log('Reset Zoom clicked');
                onResetZoom();
                setOpenMenu(null);
              }}
            >
              <span>Reset Zoom</span>
              <span style={{ opacity: 0.5, marginLeft: 20 }}>⌘0</span>
            </div>
          </>)}
        </div>
        <div style={{ cursor: 'pointer', position: 'relative' }}>
          <span className="menu-trigger" onClick={(e) => {
            e.preventDefault();
            console.log('Library menu clicked');
            setOpenMenu(openMenu === 'library' ? null : 'library');
          }}>Library</span>
          {menuDropdown('library', <>
            <div
              style={{ padding: '8px 20px', cursor: 'pointer' }}
              onClick={(e) => {
                e.preventDefault();
                e.stopPropagation();
                console.log('Save to Library clicked');
                const name = window.prompt('Enter a name for this template:');
                if (name) {
                  const library = JSON.parse(localStorage.getItem('mindmap_library') || '{}');
                  library[name] = nodes;
                  localStorage.setItem('mindmap_library', JSON.stringify(library));
                  alert('Template saved to library');
                }
                setOpenMenu(null);
              }}
            >Save to Library</div>
            <div
              style={{ padding: '8px 20px', cursor: 'pointer' }}
              onClick={(e) => {
                e.preventDefault();
                e.stopPropagation();
                console.log('Load from Library clicked');
                const library = JSON.parse(localStorage.getItem('mindmap_library') || '{}');
                const templates = Object.keys(library);
                if (templates.length === 0) {
                  alert('No templates in library');
                  return;
                }
                const name = window.prompt('Enter template name to load:\n\nAvailable templates:\n' + templates.join('\n'));
                if (name && library[name]) {
                  setNodes([...library[name]]);
                  setUndoStack([]);
                  setRedoStack([]);
                  setSelectedNodeId(null);
                  if (canvasRef.current?.center) {
                    canvasRef.current.center();
                  }
                } else if (name) {
                  alert('Template not found');
                }
                setOpenMenu(null);
              }}
            >Load from Library</div>
            <div
              style={{ padding: '8px 20px', cursor: 'pointer' }}
              onClick={(e) => {
                e.preventDefault();
                e.stopPropagation();
                console.log('Delete from Library clicked');
                const library = JSON.parse(localStorage.getItem('mindmap_library') || '{}');
                const templates = Object.keys(library);
                if (templates.length === 0) {
                  alert('No templates in library');
                  return;
                }
                const name = window.prompt('Enter template name to delete:\n\nAvailable templates:\n' + templates.join('\n'));
                if (name && library[name]) {
                  delete library[name];
                  localStorage.setItem('mindmap_library', JSON.stringify(library));
                  alert('Template deleted from library');
                } else if (name) {
                  alert('Template not found');
                }
                setOpenMenu(null);
              }}
            >Delete from Library</div>
          </>)}
        </div>
        <div style={{ cursor: 'pointer', position: 'relative' }}>
          <span className="menu-trigger" onClick={(e) => {
            e.preventDefault();
            console.log('Settings menu clicked');
            setOpenMenu(openMenu === 'settings' ? null : 'settings');
          }}>Settings</span>
          {menuDropdown('settings', <>
            <div
              style={{ padding: '8px 20px', cursor: 'pointer' }}
              onClick={(e) => {
                e.preventDefault();
                e.stopPropagation();
                console.log('Toggle Dark Mode clicked');
                onToggleDark();
                setOpenMenu(null);
              }}
            >Toggle Dark Mode</div>
          </>)}
        </div>
      </div>
    </nav>
  );
}

function HelpPanel({ isVisible }) {
  const rulesClass = `rules ${isVisible ? 'show' : ''}`;
  return (
    <div className="help">
      <div className={rulesClass}>
        <div className="rule"><span className="key">Tab</span><span className="desc">插入子节点</span></div>
        <div className="rule"><span className="key">Enter</span><span className="desc">插入后置节点</span></div>
        <div className="rule"><span className="key">Shift</span>+<span className="key">Enter</span><span className="desc">插入前置节点</span></div>
        <div className="rule"><span className="key">Ctrl</span>+<span className="key">Enter</span><span className="desc">插入父节点</span></div>
        <div className="rule"><span className="key">Ctrl</span>+<span className="key">←↑↓→</span><span className="desc">多节点选择</span></div>
        <div className="rule"><span className="key">Shift</span>+<span className="key">←↑↓→</span><span className="desc">移动节点</span></div>
        <div className="rule"><span className="key">Ctrl</span>+<span className="key">e</span><span className="desc">展开/收起节点</span></div>
        <div className="rule"><span className="key">Space</span>+<span className="key">左键</span><span className="desc">拖动画布</span></div>
        <div className="rule"><span className="key">Ctrl</span>+<span className="key">o</span><span className="desc">导入文件</span></div>
        <div className="rule"><span className="key">Ctrl</span>+<span className="key">s</span><span className="desc">导出为文件</span></div>
        <div className="rule"><span className="key">Ctrl</span>+<span className="key">Shift</span>+<span className="key">s</span><span className="desc">导出为图片</span></div>
      </div>
    </div>
  );
}

function MainHeader() {
  return <header />;
}

function App() {
  const [undoStack, setUndoStack] = useState([]);
  const [redoStack, setRedoStack] = useState([]);
  const canvasRef = useRef();
  const fileInputRef = useRef();

  // Mind map state with localStorage persistence
  const [nodes, setNodes] = useState(() => {
    const savedNodes = localStorage.getItem('mindmap_nodes');
    if (savedNodes) {
      try {
        return JSON.parse(savedNodes);
      } catch (e) {
        console.error('Failed to parse saved nodes:', e);
      }
    }
    return [
      { id: 1, label: '中心主题', x: 400, y: 300, parentId: null },
      { id: 2, label: '分支1', x: 250, y: 200, parentId: 1 },
      { id: 3, label: '分支2', x: 550, y: 200, parentId: 1 },
      { id: 4, label: '分支3', x: 250, y: 400, parentId: 1 },
      { id: 5, label: '分支4', x: 550, y: 400, parentId: 1 },
    ];
  });
  const [selectedNodeId, setSelectedNodeId] = useState(null);

  // Helper to push to undo stack
  const pushUndo = useCallback((newNodes) => {
    console.log('Push to undo stack:', {
      currentNodes: nodes.length,
      newNodes: newNodes.length,
      undoStackSize: undoStack.length,
      redoStackSize: redoStack.length
    });
    setUndoStack(stack => [...stack, [...nodes]]);
    setRedoStack(() => []);
    setNodes(() => Array.isArray(newNodes) ? [...newNodes] : []);
  }, [nodes, undoStack.length, redoStack.length]);

  // Undo/Redo handlers
  const handleUndo = () => {
    if (undoStack.length === 0) {
      console.log('Cannot undo - stack empty');
      return;
    }
    console.log('Undo:', {
      undoStackSize: undoStack.length,
      redoStackSize: redoStack.length,
      currentNodes: nodes.length
    });
    const prevNodes = undoStack[undoStack.length - 1];
    setNodes([...prevNodes]);
    setRedoStack(rstack => [[...nodes], ...rstack]);
    setUndoStack(stack => stack.slice(0, -1));
  };

  const handleRedo = () => {
    if (redoStack.length === 0) {
      console.log('Cannot redo - stack empty');
      return;
    }
    console.log('Redo:', {
      undoStackSize: undoStack.length,
      redoStackSize: redoStack.length,
      currentNodes: nodes.length
    });
    const nextNodes = redoStack[0];
    setNodes([...nextNodes]);
    setUndoStack(stack => [...stack, [...nodes]]);
    setRedoStack(stack => stack.slice(1));
  };

  // Save nodes to localStorage whenever they change
  useEffect(() => {
    localStorage.setItem('mindmap_nodes', JSON.stringify(nodes));
  }, [nodes]);

  // Handle keyboard shortcuts
  useEffect(() => {
    const handleKeyDown = (e) => {
      const isCommandKey = e.metaKey || e.ctrlKey;

      // Handle help panel visibility
      if (e.code.toLowerCase() === 'escape') {
        setIsHelpVisible(false);
        window.localStorage.setItem('xmindHelpTriggerState', '0');
      }

      // Handle command key combinations
      if (isCommandKey) {
        switch (e.key.toLowerCase()) {
          case 'n':
            e.preventDefault();
            const initialNodes = [{ id: 1, label: '中心主题', x: 400, y: 300, parentId: null }];
            setNodes([...initialNodes]);
            setUndoStack([]);
            setRedoStack([]);
            setSelectedNodeId(null);
            localStorage.removeItem('mindmap_nodes');
            setTimeout(() => {
              if (canvasRef.current?.center) canvasRef.current.center();
            }, 0);
            break;

          case 's':
            e.preventDefault();
            if (e.shiftKey) {
              alert('Export as PNG not implemented yet.');
            } else {
              const blob = new Blob([JSON.stringify(nodes, null, 2)], { type: 'application/json' });
              const url = URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = url;
              const now = new Date();
              const pad = n => n.toString().padStart(2, '0');
              const filename = `graph-${now.getFullYear()}${pad(now.getMonth()+1)}${pad(now.getDate())}-${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}.json`;
              a.download = filename;
              document.body.appendChild(a);
              a.click();
              setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
              }, 0);
            }
            break;

          case 'o':
            e.preventDefault();
            fileInputRef.current?.click();
            break;

          case 'z':
            e.preventDefault();
            if (e.shiftKey) {
              handleRedo();
            } else {
              handleUndo();
            }
            break;
        }
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [nodes, undoStack, redoStack, canvasRef, handleUndo, handleRedo]);

  // Node click handler
  const handleNodeClick = (nodeId) => {
    console.log('Node clicked:', { nodeId, currentSelected: selectedNodeId });
    setSelectedNodeId(nodeId);
  };

  // Keyboard shortcuts for editing and deleting
  useEffect(() => {
    const handleKeyDown = (e) => {
      if (!selectedNodeId) {
        console.log('No node selected for keyboard action');
        return;
      }

      // Add child node on Tab
      if (e.key === 'Tab') {
        e.preventDefault();
        pushUndo((nodes => {
          const parent = nodes.find(n => n.id === selectedNodeId);
          if (!parent) return nodes;
          const maxId = Math.max(...nodes.map(n => n.id));
          const angle = Math.random() * 2 * Math.PI;
          const dist = 120;
          const x = parent.x + Math.cos(angle) * dist;
          const y = parent.y + Math.sin(angle) * dist;
          return [
            ...nodes,
            { id: maxId + 1, label: '新节点', x, y, parentId: parent.id }
          ];
        })(nodes));
      }

      // Rename node on Enter
      if (e.key === 'Enter' && !e.shiftKey && !e.ctrlKey) {
        e.preventDefault();
        const newLabel = window.prompt('输入新名称:', nodes.find(n => n.id === selectedNodeId)?.label || '');
        if (newLabel) {
          pushUndo(nodes.map(n => n.id === selectedNodeId ? { ...n, label: newLabel } : n));
        }
      }

      // Delete node and its children on Delete/Backspace
      if (e.key === 'Delete' || e.key === 'Backspace') {
        e.preventDefault();
        pushUndo((nodes => {
          const collectIds = (id, acc) => {
            acc.push(id);
            nodes.filter(n => n.parentId === id).forEach(n => collectIds(n.id, acc));
            return acc;
          };
          const idsToDelete = collectIds(selectedNodeId, []);
          return nodes.filter(n => !idsToDelete.includes(n.id));
        })(nodes));
        setSelectedNodeId(null);
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [selectedNodeId, nodes, pushUndo]);

  // Help panel visibility state
  const [isHelpVisible, setIsHelpVisible] = useState(true);

  // Load help panel state from localStorage on initial render
  useEffect(() => {
    const savedState = window.localStorage.getItem('xmindHelpTriggerState');
    setIsHelpVisible(savedState !== '0');
  }, []);

  const triggerClass = `trigger ${isHelpVisible ? 'active' : ''}`;

  return (
    <React.Fragment>
      <MenuBar
        onExport={() => {
          const blob = new Blob([JSON.stringify(nodes, null, 2)], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          const now = new Date();
          const pad = n => n.toString().padStart(2, '0');
          const filename = `graph-${now.getFullYear()}${pad(now.getMonth()+1)}${pad(now.getDate())}-${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}.json`;
          a.download = filename;
          document.body.appendChild(a);
          a.click();
          setTimeout(() => {
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
          }, 0);
        }}
        onImport={(data) => {
          console.log('Importing data:', data);
          setNodes([...data]);
          setUndoStack([]);
          setRedoStack([]);
          setSelectedNodeId(null);
          setTimeout(() => {
            if (canvasRef.current?.center) canvasRef.current.center();
          }, 0);
        }}
        onNew={() => {
          const initialNodes = [{ id: 1, label: '中心主题', x: 400, y: 300, parentId: null }];
          setNodes([...initialNodes]);
          setUndoStack([]);
          setRedoStack([]);
          setSelectedNodeId(null);
          localStorage.removeItem('mindmap_nodes');
          setTimeout(() => {
            if (canvasRef.current?.center) canvasRef.current.center();
          }, 0);
        }}
        onExportPNG={() => alert('Export as PNG not implemented yet.')}
        onUndo={handleUndo}
        onRedo={handleRedo}
        onDelete={() => {
          if (!selectedNodeId) return;
          pushUndo((nodes => {
            const collectIds = (id, acc) => {
              acc.push(id);
              nodes.filter(n => n.parentId === id).forEach(n => collectIds(n.id, acc));
              return acc;
            };
            const idsToDelete = collectIds(selectedNodeId, []);
            return nodes.filter(n => !idsToDelete.includes(n.id));
          })(nodes));
          setSelectedNodeId(null);
        }}
        onCenter={() => canvasRef.current?.center()}
        onZoomIn={() => canvasRef.current?.zoom(1.1)}
        onZoomOut={() => canvasRef.current?.zoom(0.9)}
        onResetZoom={() => canvasRef.current?.resetZoom()}
        onToggleDark={() => alert('Dark mode not implemented yet.')}
        nodes={nodes}
        setNodes={setNodes}
        setUndoStack={setUndoStack}
        setRedoStack={setRedoStack}
        setSelectedNodeId={setSelectedNodeId}
        canvasRef={canvasRef}
      />
      <div style={{ height: 48 }} />
      <MainHeader />

      {/* Help trigger button */}
      <div style={{ position: 'fixed', right: 32, bottom: 32, zIndex: 10010 }}>
        <div className={triggerClass} onClick={() => {
          const newVisibility = !isHelpVisible;
          setIsHelpVisible(newVisibility);
          window.localStorage.setItem('xmindHelpTriggerState', newVisibility ? '1' : '0');
        }}>
          <i className="trigger-icon" />
          <div className="trigger-tooltip">
            {isHelpVisible ? '收起' : '帮助'}
          </div>
        </div>
      </div>

      <HelpPanel isVisible={isHelpVisible} />

      {/* Mind map canvas */}
      <MindMapCanvas
        ref={canvasRef}
        nodes={nodes}
        onNodeClick={handleNodeClick}
        selectedNodeId={selectedNodeId}
        onNodePositionChange={(id, x, y) => {
          pushUndo(nodes.map(n => n.id === id ? { ...n, x, y } : n));
        }}
      />
    </React.Fragment>
  );
}

export default App;
